/**
 * Security API Service
 * Handles all security-related API calls
 * Currently uses mock data for development
 */

import {
  MFAUser,
  MFASettings,
  MFAStats,
  SSOProvider,
  SSOEvent,
  SSOStats,
  SecurityEvent,
  SecurityEventStats,
  SecurityEventFilters,
  Threat,
  BlockedIP,
  ThreatRule,
  ThreatStats,
  SecurityAlert,
  SecurityDashboardData,
} from '../../modules/security/types';
import { ApiResponse } from '../../types';

// Mock Mode Toggle
const MOCK_MODE = true;

// ============================================
// MOCK DATA - MFA
// ============================================

const MOCK_MFA_USERS: MFAUser[] = [
  ...Array.from({ length: 30 }, (_, i) => ({
    id: `user-mfa-${i + 1}`,
    name: `User ${i + 1}`,
    email: `user${i + 1}@example.com`,
    mfaEnabled: true,
    mfaMethods: [
      ['totp', 'backup_codes'],
      ['sms', 'email'],
      ['totp'],
      ['fido2', 'totp', 'backup_codes'],
      ['sms'],
    ][i % 5] as ('sms' | 'email' | 'totp' | 'backup_codes' | 'fido2')[],
    enrolledAt: new Date(2024, 10 - (i % 6), i + 1).toISOString(),
    lastLogin: new Date(2024, 10, 30 - (i % 7)).toISOString(),
    tenantId: `tenant-${(i % 5) + 1}`,
    tenantName: `${['Central', 'Royal', 'Elite', 'Prime', 'Smart'][i % 5]} Library`,
  })),
  ...Array.from({ length: 20 }, (_, i) => ({
    id: `user-no-mfa-${i + 1}`,
    name: `User ${i + 31}`,
    email: `user${i + 31}@example.com`,
    mfaEnabled: false,
    mfaMethods: [] as ('sms' | 'email' | 'totp' | 'backup_codes' | 'fido2')[],
    lastLogin: new Date(2024, 10, 30 - (i % 10)).toISOString(),
    tenantId: `tenant-${(i % 5) + 1}`,
    tenantName: `${['Central', 'Royal', 'Elite', 'Prime', 'Smart'][i % 5]} Library`,
  })),
];

const MOCK_MFA_SETTINGS: MFASettings = {
  enforceForAll: false,
  enforceForAdmins: true,
  allowOptIn: true,
  gracePeriodDays: 7,
  supportedMethods: {
    sms: true,
    email: true,
    totp: true,
    backupCodes: true,
    fido2: true,
  },
};

// ============================================
// MOCK DATA - SSO
// ============================================

const MOCK_SSO_PROVIDERS: SSOProvider[] = [
  {
    id: 'google-1',
    name: 'Google Workspace',
    type: 'google',
    status: 'active',
    connectedUsers: 45,
    lastSync: new Date(2024, 10, 31, 10, 30).toISOString(),
    logo: 'https://www.google.com/favicon.ico',
    config: {
      clientId: 'google-client-id-123',
      redirectUri: 'https://studyspot.com/auth/google/callback',
      scopes: ['openid', 'profile', 'email'],
      domainRestriction: 'example.com',
      autoProvision: true,
      defaultRole: 'user',
    },
  },
  {
    id: 'azure-1',
    name: 'Microsoft Azure AD',
    type: 'azure',
    status: 'active',
    connectedUsers: 32,
    lastSync: new Date(2024, 10, 31, 9, 15).toISOString(),
    logo: 'https://www.microsoft.com/favicon.ico',
    config: {
      clientId: 'azure-client-id-456',
      redirectUri: 'https://studyspot.com/auth/azure/callback',
      scopes: ['openid', 'profile', 'email'],
      autoProvision: true,
      defaultRole: 'user',
    },
  },
  {
    id: 'okta-1',
    name: 'Okta',
    type: 'okta',
    status: 'active',
    connectedUsers: 18,
    lastSync: new Date(2024, 10, 31, 8, 45).toISOString(),
    logo: 'https://www.okta.com/favicon.ico',
    config: {
      clientId: 'okta-client-id-789',
      redirectUri: 'https://studyspot.com/auth/okta/callback',
      scopes: ['openid', 'profile', 'email'],
      autoProvision: false,
      defaultRole: 'user',
    },
  },
  {
    id: 'auth0-1',
    name: 'Auth0',
    type: 'auth0',
    status: 'configured',
    connectedUsers: 0,
    logo: 'https://auth0.com/favicon.ico',
  },
  {
    id: 'saml-1',
    name: 'Custom SAML 2.0',
    type: 'saml',
    status: 'not_configured',
    connectedUsers: 0,
  },
];

const MOCK_SSO_EVENTS: SSOEvent[] = Array.from({ length: 100 }, (_, i) => ({
  id: `sso-event-${i + 1}`,
  userId: `user-${(i % 50) + 1}`,
  userName: `User ${(i % 50) + 1}`,
  userEmail: `user${(i % 50) + 1}@example.com`,
  provider: ['Google Workspace', 'Microsoft Azure AD', 'Okta'][i % 3],
  action: ['login', 'logout', 'sync'][i % 3] as 'login' | 'logout' | 'sync',
  status: i % 10 === 0 ? 'failed' : 'success',
  timestamp: new Date(2024, 10, 30 - (i % 7), 10 + (i % 12), i % 60).toISOString(),
  ipAddress: `192.168.${i % 255}.${(i * 3) % 255}`,
  errorMessage: i % 10 === 0 ? 'Invalid credentials' : undefined,
}));

// ============================================
// MOCK DATA - Security Events
// ============================================

const EVENT_TYPES = ['login', 'logout', 'password_change', 'mfa', 'permission_change', 'data_access', 'api_call', 'export', 'delete'] as const;
const SEVERITIES = ['critical', 'high', 'medium', 'low', 'info'] as const;
const COUNTRIES = [
  { city: 'Mumbai', country: 'India', countryCode: 'IN' },
  { city: 'New York', country: 'USA', countryCode: 'US' },
  { city: 'London', country: 'UK', countryCode: 'GB' },
  { city: 'Singapore', country: 'Singapore', countryCode: 'SG' },
  { city: 'Dubai', country: 'UAE', countryCode: 'AE' },
  { city: 'Sydney', country: 'Australia', countryCode: 'AU' },
];

const MOCK_SECURITY_EVENTS: SecurityEvent[] = Array.from({ length: 500 }, (_, i) => {
  const eventType = EVENT_TYPES[i % EVENT_TYPES.length];
  const status = i % 15 === 0 ? 'failed' : i % 20 === 0 ? 'blocked' : 'success';
  const severity = eventType === 'delete' || eventType === 'permission_change' ? 'critical' :
                   eventType === 'export' || eventType === 'data_access' ? 'high' :
                   eventType === 'password_change' ? 'medium' :
                   eventType === 'mfa' ? 'low' : 'info';
  
  return {
    id: `event-${i + 1}`,
    timestamp: new Date(2024, 10, 30 - (i % 30), 10 + (i % 14), i % 60).toISOString(),
    eventType,
    severity,
    userId: `user-${(i % 50) + 1}`,
    userName: `User ${(i % 50) + 1}`,
    userEmail: `user${(i % 50) + 1}@example.com`,
    ipAddress: `192.168.${i % 255}.${(i * 3) % 255}`,
    location: COUNTRIES[i % COUNTRIES.length],
    device: ['Desktop', 'Mobile', 'Tablet'][i % 3],
    browser: ['Chrome', 'Firefox', 'Safari', 'Edge'][i % 4],
    status,
    details: {
      action: eventType,
      resource: eventType === 'data_access' ? 'Student Records' : eventType === 'export' ? 'User List' : undefined,
      changes: eventType === 'permission_change' ? ['admin_access'] : undefined,
    },
    tenantId: `tenant-${(i % 5) + 1}`,
    tenantName: `${['Central', 'Royal', 'Elite', 'Prime', 'Smart'][i % 5]} Library`,
  };
});

// ============================================
// MOCK DATA - Threats
// ============================================

const MOCK_THREATS: Threat[] = Array.from({ length: 20 }, (_, i) => ({
  id: `threat-${i + 1}`,
  type: ['brute_force', 'suspicious_location', 'anomalous_behavior', 'account_takeover'][i % 4] as any,
  severity: ['critical', 'high', 'medium'][i % 3] as any,
  status: i < 5 ? 'active' : i < 10 ? 'investigating' : i < 15 ? 'resolved' : 'false_positive',
  detectedAt: new Date(2024, 10, 30 - (i % 7), 10 + (i % 12)).toISOString(),
  userId: i % 3 === 0 ? `user-${(i % 20) + 1}` : undefined,
  userName: i % 3 === 0 ? `User ${(i % 20) + 1}` : undefined,
  userEmail: i % 3 === 0 ? `user${(i % 20) + 1}@example.com` : undefined,
  ipAddress: `192.168.${i % 255}.${(i * 7) % 255}`,
  description: [
    'Multiple failed login attempts detected',
    'Login from unusual location',
    'Unusual data access pattern',
    'Potential account takeover attempt',
  ][i % 4],
  details: {
    attempts: i % 4 === 0 ? 10 + (i % 10) : undefined,
    location: i % 4 === 1 ? COUNTRIES[i % COUNTRIES.length] : undefined,
    accessCount: i % 4 === 2 ? 50 + (i % 50) : undefined,
  },
  actions: ['Blocked IP', 'Sent alert', 'Disabled account'][i % 3] ? [['Blocked IP', 'Sent alert', 'Disabled account'][i % 3]] : [],
  resolvedAt: i >= 10 ? new Date(2024, 10, 31, 10 + (i % 12)).toISOString() : undefined,
  resolvedBy: i >= 10 ? 'admin@studyspot.com' : undefined,
}));

const MOCK_BLOCKED_IPS: BlockedIP[] = Array.from({ length: 50 }, (_, i) => ({
  id: `blocked-ip-${i + 1}`,
  ip: `192.168.${i % 255}.${(i * 5) % 255}`,
  reason: ['Brute force attack', 'Suspicious activity', 'Known malicious IP', 'Multiple failed logins'][i % 4],
  blockedAt: new Date(2024, 10, 30 - (i % 7), 10 + (i % 12)).toISOString(),
  expiresAt: new Date(2024, 11, 1 + (i % 7), 10 + (i % 12)).toISOString(),
  threatType: ['brute_force', 'suspicious_location', 'anomalous_behavior'][i % 3],
  autoBlocked: i % 3 !== 0,
  country: COUNTRIES[i % COUNTRIES.length].country,
  attempts: 5 + (i % 20),
}));

const MOCK_THREAT_RULES: ThreatRule[] = [
  {
    id: 'rule-1',
    name: 'Block after 5 failed logins',
    description: 'Automatically block IP after 5 failed login attempts within 5 minutes',
    enabled: true,
    condition: {
      eventType: 'login',
      frequency: 5,
      timeWindow: 5,
    },
    action: 'block',
    severity: 'high',
    createdAt: new Date(2024, 9, 1).toISOString(),
    updatedAt: new Date(2024, 10, 15).toISOString(),
  },
  {
    id: 'rule-2',
    name: 'Alert on login from new country',
    description: 'Send alert when user logs in from a country they have never logged in from',
    enabled: true,
    condition: {
      eventType: 'login',
      frequency: 1,
      timeWindow: 1,
    },
    action: 'alert',
    severity: 'medium',
    createdAt: new Date(2024, 9, 1).toISOString(),
    updatedAt: new Date(2024, 10, 15).toISOString(),
  },
  {
    id: 'rule-3',
    name: 'Block known malicious IPs',
    description: 'Automatically block IPs from known threat intelligence feeds',
    enabled: true,
    condition: {
      eventType: 'login',
      frequency: 1,
      timeWindow: 1,
    },
    action: 'block',
    severity: 'critical',
    createdAt: new Date(2024, 9, 1).toISOString(),
    updatedAt: new Date(2024, 10, 15).toISOString(),
  },
  {
    id: 'rule-4',
    name: 'Alert on admin permission changes',
    description: 'Send alert when admin permissions are modified',
    enabled: true,
    condition: {
      eventType: 'permission_change',
      frequency: 1,
      timeWindow: 1,
    },
    action: 'alert',
    severity: 'critical',
    createdAt: new Date(2024, 9, 1).toISOString(),
    updatedAt: new Date(2024, 10, 15).toISOString(),
  },
  {
    id: 'rule-5',
    name: 'Block VPN/Proxy logins',
    description: 'Block login attempts from VPN or proxy servers',
    enabled: false,
    condition: {
      eventType: 'login',
      frequency: 1,
      timeWindow: 1,
    },
    action: 'block',
    severity: 'medium',
    createdAt: new Date(2024, 9, 1).toISOString(),
    updatedAt: new Date(2024, 10, 15).toISOString(),
  },
];

// ============================================
// SERVICE CLASS
// ============================================

class SecurityService {
  /**
   * Get MFA users
   */
  async getMFAUsers(): Promise<ApiResponse<MFAUser[]>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      return {
        success: true,
        data: MOCK_MFA_USERS,
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get MFA settings
   */
  async getMFASettings(): Promise<ApiResponse<MFASettings>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      return {
        success: true,
        data: MOCK_MFA_SETTINGS,
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Update MFA settings
   */
  async updateMFASettings(settings: Partial<MFASettings>): Promise<ApiResponse<MFASettings>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      return {
        success: true,
        data: { ...MOCK_MFA_SETTINGS, ...settings },
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get MFA statistics
   */
  async getMFAStats(): Promise<ApiResponse<MFAStats>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const mfaEnabled = MOCK_MFA_USERS.filter((u) => u.mfaEnabled).length;
      const totalUsers = MOCK_MFA_USERS.length;
      
      return {
        success: true,
        data: {
          totalUsers,
          mfaEnabled,
          mfaDisabled: totalUsers - mfaEnabled,
          enrollmentRate: (mfaEnabled / totalUsers) * 100,
          methodsUsage: {
            sms: MOCK_MFA_USERS.filter((u) => u.mfaMethods.includes('sms')).length,
            email: MOCK_MFA_USERS.filter((u) => u.mfaMethods.includes('email')).length,
            totp: MOCK_MFA_USERS.filter((u) => u.mfaMethods.includes('totp')).length,
            backupCodes: MOCK_MFA_USERS.filter((u) => u.mfaMethods.includes('backup_codes')).length,
            fido2: MOCK_MFA_USERS.filter((u) => u.mfaMethods.includes('fido2')).length,
          },
        },
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get SSO providers
   */
  async getSSOProviders(): Promise<ApiResponse<SSOProvider[]>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      return {
        success: true,
        data: MOCK_SSO_PROVIDERS,
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get SSO events
   */
  async getSSOEvents(): Promise<ApiResponse<SSOEvent[]>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      return {
        success: true,
        data: MOCK_SSO_EVENTS,
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get SSO statistics
   */
  async getSSOStats(): Promise<ApiResponse<SSOStats>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const activeProviders = MOCK_SSO_PROVIDERS.filter((p) => p.status === 'active');
      const totalUsers = activeProviders.reduce((sum, p) => sum + p.connectedUsers, 0);
      const successfulLogins = MOCK_SSO_EVENTS.filter((e) => e.status === 'success').length;
      
      return {
        success: true,
        data: {
          activeIntegrations: activeProviders.length,
          totalUsersViaSSO: totalUsers,
          successRate: (successfulLogins / MOCK_SSO_EVENTS.length) * 100,
          lastSync: activeProviders[0]?.lastSync,
        },
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get security events
   */
  async getSecurityEvents(filters?: SecurityEventFilters): Promise<ApiResponse<SecurityEvent[]>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      let events = [...MOCK_SECURITY_EVENTS];
      
      // Apply filters (simplified)
      if (filters?.eventType) {
        events = events.filter((e) => e.eventType === filters.eventType);
      }
      if (filters?.severity) {
        events = events.filter((e) => e.severity === filters.severity);
      }
      if (filters?.status) {
        events = events.filter((e) => e.status === filters.status);
      }
      
      return {
        success: true,
        data: events,
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get security event statistics
   */
  async getSecurityEventStats(): Promise<ApiResponse<SecurityEventStats>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const last24h = MOCK_SECURITY_EVENTS.filter((e) => {
        const eventDate = new Date(e.timestamp);
        const now = new Date();
        return (now.getTime() - eventDate.getTime()) / (1000 * 60 * 60) <= 24;
      });
      
      return {
        success: true,
        data: {
          total24h: last24h.length,
          critical: last24h.filter((e) => e.severity === 'critical').length,
          warning: last24h.filter((e) => e.severity === 'high' || e.severity === 'medium').length,
          info: last24h.filter((e) => e.severity === 'low' || e.severity === 'info').length,
          successRate: (last24h.filter((e) => e.status === 'success').length / last24h.length) * 100,
        },
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get threats
   */
  async getThreats(): Promise<ApiResponse<Threat[]>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      return {
        success: true,
        data: MOCK_THREATS,
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get blocked IPs
   */
  async getBlockedIPs(): Promise<ApiResponse<BlockedIP[]>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      return {
        success: true,
        data: MOCK_BLOCKED_IPS,
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get threat rules
   */
  async getThreatRules(): Promise<ApiResponse<ThreatRule[]>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      return {
        success: true,
        data: MOCK_THREAT_RULES,
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get threat statistics
   */
  async getThreatStats(): Promise<ApiResponse<ThreatStats>> {
    if (MOCK_MODE) {
      await new Promise((resolve) => setTimeout(resolve, 300));
      const activeThreats = MOCK_THREATS.filter((t) => t.status === 'active').length;
      const suspiciousActivities = MOCK_THREATS.filter((t) => t.status === 'investigating').length;
      
      return {
        success: true,
        data: {
          activeThreats,
          blockedIPs: MOCK_BLOCKED_IPS.length,
          suspiciousActivities,
          riskScore: Math.min(100, (activeThreats * 10) + (suspiciousActivities * 5)),
        },
      };
    }
    throw new Error('Real API not implemented yet');
  }

  /**
   * Get dashboard data
   */
  async getDashboardData(): Promise<ApiResponse<SecurityDashboardData>> {
    if (MOCK_MODE) {
      const [mfaStats, ssoStats, eventStats, threatStats] = await Promise.all([
        this.getMFAStats(),
        this.getSSOStats(),
        this.getSecurityEventStats(),
        this.getThreatStats(),
      ]);
      
      return {
        success: true,
        data: {
          mfaStats: mfaStats.data!,
          ssoStats: ssoStats.data!,
          eventStats: eventStats.data!,
          threatStats: threatStats.data!,
        },
      };
    }
    throw new Error('Real API not implemented yet');
  }
}

export const securityService = new SecurityService();


